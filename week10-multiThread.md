# 목표  
자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.  

# 학습할 것(필수)  
- Thread 클래스와 Runnable 인터페이스  
- 쓰레드의 상태  
- 쓰레드의 우선순위  
- Main 쓰레드  
- 동기화  
- 데드락  

# Today Keyword  
- https://sujl95.tistory.com/63
-  
-  

- - -


## Thread 클래스와 Runnable 인터페이스  

- 쓰레드와 프로세스의 차이  
프로세스 : 운영체제에서 실행되는 하나의 프로그램 단위.  
쓰레드 : 프로세스 내에서 실행되는 세부 작업단위.  
멀티쓰레드 : 프로세스가 하나 이상의 쓰레드를 사용하는 경우.  

- Thread 클래스를 상속  
```
class ThreadEx1 extends Thread{
public void run(){
//작업내용
}
}
ThreadEx1 ex1 = new ThreadEx1();
ex1.start();
```

- Runnable 인터페이스를 구현 -> 재사용성이 높고 코드의 일관성을 유지하기 때문에 Thread 클래스보다 객체지향적.  
```
class ThreadEx2 implements Runnable{
public void run(){
//작업내용
}
}
ThreadEx2 ex2 = ThreadEx2();
Thread t = new Thread(ex2);
t.start();
```
- start(), run() 에 대한 차이와 쓰레드가 실행되는 과정  
run() : 단순히 메서드를 호출함.  
start() : 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음 run() 을 호출해서, 생성된 호출스택에 run()이 첫번째로 저장되게 함.  

[쓰레드 참고](https://dev-troh.tistory.com/47)  


## 쓰레드의 상태  

|상태|열거상수|설명|
|------|---|---|
|객체생성|NEW|쓰레드 객체가 생성, 아직 start() 메소드가 호출되지 않은 상태|
|실행대기|RUNNABLE|실행상태로 언제든지 갈 수 있는 상태|
|일시정지|WAITING|다른 쓰레드가 통지할 때까지 기다리는 상태|
|일시정지|TIMED_WAITING|주어진 시간 동안 기다리는 상태|
|일시정지|BLOCKED|사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태|
|종료|TERMINATED|실행을 마친 상태|

[쓰레드 상태](https://widevery.tistory.com/27)  

## 쓰레드의 우선순위  

멀티스레드란 : 여러 개의 스레드를 생성하여 운영하는 방법.  
-> 동시성 : 싱글 코어에서 번갈아가면서 실행, 병렬성 : 멀티 코어에서 개별 스레드를 동시에 실행함.  

스레드 스케줄링이란 : 멀티스레드의 우선순위 정하는 것.  
-> 우선순위(Priority) 방식과 순환할당(Round-Robin) 방식이 있음.  
```
-우선순위 방식 : 우선 순위 방식은 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케줄링 하는 것을 말하며 setPriority()메소드를 사용하여 우선순위를 설정합니다.
-순환 할당 방식 : 순환 할당방식은 시간 할당량(Time Slice)을 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식입니다.
```

[스레드 우선순위 참고](https://coding-factory.tistory.com/569)  

## Main 쓰레드  

- 모든 자바 어플리케이션은 메인 스레드가 main() 메소드를 실행하면서 시작됨.  

싱글스레드는 메인 스레드가 종료되면 프로세스도 종료되지만,  
멀티스레드는 메인스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료하지 않음.   


[메인스레드 참고](https://honbabzone.com/java/java-thread/)

## 동기화  

-멀티스레드 프로그래밍에서 스레드를 동기화해줘야함.  
-> 여러 개의 스레드가 같은 프로세스의 자원을 공유하면서 작업하는 경우에 서로의 작업이 다른 작업에 영향을 주기 때문.  
-> 스레드의 동기화를 위해 임계영역(critical section)과 잠금(lock)을 사용한다.  
-> 임계영역을 지정하고, 임계영역이 가지고 있는 lock을 단 하나의 스레드에게 빌려주는 개념.  
-> lock은 단 하나의 스레드만이 가질 수 있고, 임계영역 내에서 수행할 코드를 수행한 이후에는 lock을 반납해야함.  

-스레드를 동기화하는 방법들  
|방법|설명|
|------|---|
|임계영역|공유 자원에 대해 단 하나의 스레드만 접근하도록 한다.</br>(하나의 프로세스에 속한 스레드만 가능)|
|뮤텍스|공유 자원에 대해 단 하나의 스레드만 접근하도록 한다.</br>(서로 다른 프로세스에 속한 스레드도 가능)|
|이벤트|특정한 사건의 발생을 다른 스레드에게 알린다.|
|세마포어|한정된 개수의 자원을 여러 스레드가 사용하려고 할 때 접근을 제한한다.|
|대기가능타이머|특정 시간이 되면 대기중이던 스레드를 깨운다.|

synchronized, wait(), notify() 등을 사용해 동기화 프로그래밍이 가능하다.  

synchronized : 스레드의 동기화. 공유 자원에 lock  
```
 public synchronized void ...
```
wait() : 스레드가 lock을 가지고 있다면 lock권한을 반납하고 대기하게 만듬.  
notify() : 대기 상태인 스레드에게 다시 lock권한을 부여하고 수행하게 만든다.  

[스레드동기화 참고](https://kyun2.tistory.com/12)

## 데드락  

- 멀티스레드 환경에서 경쟁상태와 데드락을 조심해야함.  

- 경쟁상태(race condition)  
: 여러 쓰레드가 동시에 같은 데이터를 접근하여 데이터의 상태를 알 수 없게 되어버리는 경우.
 ex) 싱글톤패턴에서는 경쟁상태를 방지하기 위해 싱글톤에서 락 걸고 객체를 얻어옴.    

- 데드락(dead-lock)  
: 두개의 스레드가 있고 한스레드가 다른스레드의 동작 즉, 락이 풀리기를 서로 기다리는 바람에 영원히 풀리지 않게 되버리는 경우.
ex) Lock이 들어온 순서대로 접근했다가 순서대로 풀어야함.  


[경쟁상태와 데드락 참고](https://m.blog.naver.com/PostView.nhn?blogId=tommybee&logNo=50192920921&proxyReferer=https:%2F%2Fwww.google.com%2F)

